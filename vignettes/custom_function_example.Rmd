---
title: "Creating a custom steps function"
author: "Casey Visintin"
date: "`r Sys.Date()`"
output:
  pdf_document
geometry: margin=2cm
vignette: >
  %\VignetteIndexEntry{Custom Function}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  dpi = 300,
  fig.width = 7,
  out.width = "100%",
  cache = TRUE
)
```

Perhaps one of the most useful features of *steps* is its flexibility. Users have the options of selecting pre-defined functions or writing their own functions to use in simulations.  This vignette will describe how to implement custom functions in the *steps* software.

First, we load required packages:

```{r, message = FALSE}
library(steps)
library(raster)
library(viridisLite)
library(future)
```

To better facilitate the use of custom functions, a basic understanding of the *steps* internal structure is required. We have designed a simple and straight-forward application programming interface (API). In its most basic operation, *steps* passes landscape objects and iterator values (timesteps) to functions. These functions then return landscape objects that have been modified based on operations specified in the functions:

\begin{center}
\includegraphics[width=370px]{steps_diagram.png}
\end{center}

Landscape objects contain information on populations, carrying capacities, habitat features, and other spatially-explicit information used by dynamic functions in a simulation. Dynamics functions act on these landscape objects during a simulation.

Let's examine a pre-built *steps* dynamics function "mortality" which changes populations based on spatially-explicit values provided in a raster layer.

```{r, message = FALSE}

mortality <- function (mortality_layer, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) {

      population_raster <- landscape$population
      nstages <- raster::nlayers(population_raster)
      
      # get population as a matrix
      idx <- which(!is.na(raster::getValues(population_raster[[1]])))
      population_matrix <- raster::extract(population_raster, idx)
      
      mortality_prop <- raster::extract(landscape[[mortality_layer]][[timestep]], idx)
      
      if (is.null(stages)) stages <- seq_len(nstages)
      
      for (stage in stages) {
        
        population_matrix[ , stage] <- ceiling(population_matrix[ , stage] * mortality_prop)
        
      }
      
      # put back in the raster
      population_raster[idx] <- population_matrix
      
      landscape$population <- population_raster

    
    landscape
    
  }
  
  as.population_modification(pop_dynamics)
  
}
```    

In the first line, we have defined a function with parameters that specify the name of the layer in the landscape object that will be used to modify populations (mortality_layer) and which life stages will be modified (stages). We have set "stages" to NULL as a default so, if not specified, all stages will be modified. These are global parameters for the function. Note, we can also not define any parameters here (i.e. mortality <- function() {), but the structure is still required for the software to work.

We define an internal function (returned by the main function) on the second line and this is where the dynamic operations are specified. Note the two parameters are "landscape" and "timestep" and these are both required.

The next few lines operate on the landscape object by extracting the populations of the affected stages, extracting the values of the "mortality layer", multiplying them to get new populations, and then returning the modified populations to the landscape object. Note the last line is always "landscape" so the landscape object is returned when the function concludes its operations.

The final line assigns a class to the function. This is optional but useful to maintain an organised structure in the software. We recommend using the appropriate function based on the category of the function a user is defining. In this case, this function is a "population_modification" class since its operations change the population in the landscape object.

So let's go about creating a custom function for use in *steps*. First, we load some initial kangaroo populations:

```{r, message = FALSE, fig.align = "center"}
egk_pop

par(mar=c(0,0,0,0), oma=c(0,0,0,0))
spplot(egk_pop, col.regions = viridis(100))
```

Let's examine the total population of juveniles:

```{r, message = FALSE}
cellStats(egk_pop[[1]], sum)
```

Now, let's create a function that reduces population randomly across the landscape by a given percentage for life stages specified. We start with the first two lines coded similar to the previous example and change the function name and one of the parameters:

```{r, message = FALSE, eval = FALSE}
percent_mortality <- function (percentage, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) { ...
```

Next we extract the populations similar to the previous example. We use an index to avoid extracting missing values:

```{r, message = FALSE, eval = FALSE}
percent_mortality <- function (percentage, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) {
      population_raster <- landscape$population
      nstages <- raster::nlayers(population_raster)
      
      # get population as a matrix
      idx <- which(!is.na(raster::getValues(population_raster[[1]])))
      population_matrix <- raster::extract(population_raster, idx) ...
```

We then randomly sample cells (by non-zero indices) to be modified through an iterative process and then stop when we reach our specified target percentage reduction:

```{r, message = FALSE, eval = FALSE}
percent_mortality <- function (percentage, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) {
      population_raster <- landscape$population
      nstages <- raster::nlayers(population_raster)
      
      # get population as a matrix
      idx <- which(!is.na(raster::getValues(population_raster[[1]])))
      population_matrix <- raster::extract(population_raster, idx)
      
      if (is.null(stages)) stages <- seq_len(nstages)
      for (stage in stages) {
        initial_pop <- sum(population_matrix[ , stage])
        changing_pop <- sum(population_matrix[ , stage])
        while (changing_pop > initial_pop * percentage) {
          non_zero <- which(population_matrix[idx , stage] > 0)
          i <- sample(non_zero, 1)
          population_matrix[i , stage] <- population_matrix[i , stage] - 1
          changing_pop <- sum(population_matrix[ , stage])
        }
      } ...
```

Finally, similar to the original example, we return the modified populations to the landscape object and then return it from the function:

```{r, message = FALSE}
percent_mortality <- function (percentage, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) {
    population_raster <- landscape$population
    nstages <- raster::nlayers(population_raster)
    
    # get population as a matrix
    idx <- which(!is.na(raster::getValues(population_raster[[1]])))
    population_matrix <- raster::extract(population_raster, idx)
    
    if (is.null(stages)) stages <- seq_len(nstages)
    for (stage in stages) {
      initial_pop <- sum(population_matrix[ , stage])
      changing_pop <- sum(population_matrix[ , stage])
      while (changing_pop > initial_pop * (1 - percentage)) {
        non_zero <- which(population_matrix[ , stage] > 0)
        i <- sample(non_zero, 1)
        population_matrix[i , stage] <- population_matrix[i , stage] - 1
        changing_pop <- sum(population_matrix[ , stage])
      }
    }
    
    population_raster[idx] <- population_matrix
    landscape$population <- population_raster
    landscape
  }
} 
```

Now that we have a custom function defined in the R environment we can specify it in the model setup. Note, we specify a reduction in population by 10% (0.1) of juveniles only and run the model for a single replicate of three iterations (timesteps = 3):

```{r, message = FALSE}
ls <- landscape(population = egk_pop,
                suitability = NULL,
                carrying_capacity = NULL)

pd <- population_dynamics(change = NULL,
                          dispersal = NULL,
                          modification = percent_mortality(percentage = .10,
                                                           stages = 1),
                          density_dependence = NULL)

results <- simulation(landscape = ls,
                      population_dynamics = pd,
                      habitat_dynamics = NULL,
                      demo_stochasticity = "none",
                      timesteps = 3,
                      replicates = 1,
                      verbose = FALSE)
```

We can view the initial total juvenile populations and the modified populations in each of the timesteps:

```{r, message = FALSE}
cbind(c("t0", "t1", "t2", "t3"),
      c(cellStats(egk_pop[[1]], sum),
        cellStats(results[[1]][[1]][["population"]][[1]], sum),
        cellStats(results[[1]][[2]][["population"]][[1]], sum),
        cellStats(results[[1]][[3]][["population"]][[1]], sum)))

```
And here is a plot of the temporally-changing juvenile populations:

```{r, message = FALSE, fig.align = "center"}
pop_stack <- stack(egk_pop[[1]],
                   results[[1]][[1]][["population"]][[1]],
                   results[[1]][[2]][["population"]][[1]],
                   results[[1]][[3]][["population"]][[1]])

names(pop_stack) <- c("t0", "t1", "t2", "t3")

par(mar=c(0,0,0,0), oma=c(0,0,0,0))
spplot(pop_stack, col.regions = viridis(100))
```

Because of the internal organisation and structure of *steps*, we are also able to utilise any other information contained within the landscape object in our custom functions. For example, say we would like to reduce the populations in only highly suitable habitat (above a threshold value) - this can be parameterised in the function. 

We add an additional parameter to specify a threshold value indicating which cells in the landscape that we will randomly reduce populations in. To do this, we must also extract information from the suitability layer in the landscape object:

```{r, message = FALSE}
percent_mortality_hab <- function (percentage, threshold, stages = NULL) {
  
  pop_dynamics <- function (landscape, timestep) {
    population_raster <- landscape$population
    nstages <- raster::nlayers(population_raster)
    
    # get suitability cell indexes
    idx_hab <- which(!is.na(raster::getValues(landscape$suitability)))
    suitable <- raster::extract(landscape$suitability, idx_hab)
    
    # get population as a matrix
    idx <- which(!is.na(raster::getValues(population_raster[[1]])))
    population_matrix <- raster::extract(population_raster, idx)
    
    if (is.null(stages)) stages <- seq_len(nstages)
    for (stage in stages) {
      initial_pop <- sum(population_matrix[ , stage])
      changing_pop <- sum(population_matrix[ , stage])
      while (changing_pop > initial_pop * (1 - percentage)) {
        highly_suitable <- which(suitable >= threshold) # check for suitable cells
        non_zero <- which(population_matrix[ , stage] > 0)
        i <- sample(intersect(highly_suitable, non_zero), 1) # change the sampling pool
        population_matrix[i , stage] <- population_matrix[i , stage] - 1
        changing_pop <- sum(population_matrix[ , stage])
      }
    }
    
    population_raster[idx] <- population_matrix
    landscape$population <- population_raster
    landscape
  }
} 
```

Now we run our simulation again using the new custom function and a suitability threshold of 0.7. Note, we must also now include a suitability raster layer in the landscape object or else our function will not work:

```{r, message = FALSE}
ls <- landscape(population = egk_pop,
                suitability = egk_hab,
                carrying_capacity = NULL)

pd <- population_dynamics(change = NULL,
                          dispersal = NULL,
                          modification = percent_mortality_hab(percentage = .10,
                                                               threshold = 0.7,
                                                               stages = 1),
                          density_dependence = NULL)

results <- simulation(landscape = ls,
                      population_dynamics = pd,
                      habitat_dynamics = NULL,
                      demo_stochasticity = "none",
                      timesteps = 3,
                      replicates = 1,
                      verbose = FALSE)
```

Again, we can view the intial total juvenile populations and the modified populations in each of the timesteps:

```{r, message = FALSE}
cbind(c("t0", "t1", "t2", "t3"),
      c(cellStats(egk_pop[[1]], sum),
        cellStats(results[[1]][[1]][["population"]][[1]], sum),
        cellStats(results[[1]][[2]][["population"]][[1]], sum),
        cellStats(results[[1]][[3]][["population"]][[1]], sum)))

```
And here is an updated plot of the populations:

```{r, message = FALSE, fig.align = "center"}
pop_stack <- stack(egk_pop[[1]],
                   results[[1]][[1]][["population"]][[1]],
                   results[[1]][[2]][["population"]][[1]],
                   results[[1]][[3]][["population"]][[1]])

names(pop_stack) <- c("t0", "t1", "t2", "t3")

par(mar=c(0,0,0,0), oma=c(0,0,0,0))
spplot(pop_stack, col.regions = viridis(100))
```

Notice that whilst the total juvenile population numbers have decreased in a similar fashion, the spatial locations of the reductions have been confined to areas where habitat is highly suitable - as specified by our threshold value.

This is a simple example, but users can specify a seemingly endless configuration of dynamics to be used throughout a simulation by following the structure and methods introduced in this vignette. Anything can be stored in a landscape object and then be referred to within a custom function. Thus, the procedure for creating custom  functions also applies to habitat dynamics - which are called in the simulation function.

We encourage users to examine the pre-built functions in *steps* to get an idea of their internal operations. Further, these pre-built functions can serve as templates to get users started in customising and creating their own functions.
